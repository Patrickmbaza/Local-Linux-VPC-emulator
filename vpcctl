#!/bin/bash

set -e

# Configuration
VPC_DIR="/tmp/vpcctl"
LOG_FILE="$VPC_DIR/vpcctl.log"
FIREWALL_RULES="$VPC_DIR/firewall_rules.json"

# ==================== ENHANCED LOGGING SYSTEM ====================
# Log rotation configuration
MAX_LOG_SIZE=10485760  # 10MB in bytes
BACKUP_COUNT=5
LOG_LEVEL="INFO"  # DEBUG, INFO, WARN, ERROR

# Initialize logging system
init_logging() {
    mkdir -p "$VPC_DIR"
    touch "$LOG_FILE"
    chmod 644 "$LOG_FILE"
    
    # Log script execution start
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "=== VPCCTL STARTED: $0 $* ===" >> "$LOG_FILE"
    echo "=== Timestamp: $timestamp ===" >> "$LOG_FILE"
    echo "=== User: $(whoami) ===" >> "$LOG_FILE"
    echo "=== Hostname: $(hostname) ===" >> "$LOG_FILE"
}

# Rotate logs if they get too large
rotate_logs() {
    if [[ -f "$LOG_FILE" ]]; then
        local size=$(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)
        if [[ $size -gt $MAX_LOG_SIZE ]]; then
            log "INFO" "Log file reached $size bytes, rotating..."
            
            # Rotate backup logs
            for i in $(seq $((BACKUP_COUNT-1)) -1 1); do
                local old_file="$LOG_FILE.$i"
                local new_file="$LOG_FILE.$((i+1))"
                [[ -f "$old_file" ]] && mv "$old_file" "$new_file" 2>/dev/null || true
            done
            
            # Rotate current log
            mv "$LOG_FILE" "$LOG_FILE.1" 2>/dev/null || true
            touch "$LOG_FILE"
            chmod 644 "$LOG_FILE"
            
            log "INFO" "Log rotation completed. New log file created."
        fi
    fi
}

# Enhanced logging function with levels
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Initialize logging if not done
    mkdir -p "$VPC_DIR"
    touch "$LOG_FILE"
    rotate_logs
    
    # Check log level
    case "$level" in
        "DEBUG") [[ "$LOG_LEVEL" != "DEBUG" ]] && return ;;
        "INFO") [[ "$LOG_LEVEL" == "ERROR" ]] && return ;;
        "WARN") [[ "$LOG_LEVEL" == "ERROR" ]] && return ;;
    esac
    
    local log_entry="[$timestamp] $level: $message"
    
    # Write to log file
    echo "$log_entry" >> "$LOG_FILE"
    
    # Also print to console with colors based on level
    case "$level" in
        "ERROR")
            echo -e "${RED}$log_entry${NC}" >&2
            ;;
        "WARN")
            echo -e "${YELLOW}$log_entry${NC}"
            ;;
        "SUCCESS")
            echo -e "${GREEN}$log_entry${NC}"
            ;;
        "DEBUG")
            echo -e "${BLUE}$log_entry${NC}"
            ;;
        *)
            echo -e "${GREEN}$log_entry${NC}"
            ;;
    esac
}

# Convenience logging functions
debug() { log "DEBUG" "$1"; }
info() { log "INFO" "$1"; }
warn() { log "WARN" "$1"; }
error() { log "ERROR" "$1"; }
success() { log "SUCCESS" "$1"; }

# Log command execution with timing
log_command() {
    local cmd="$*"
    local start_time=$(date +%s)
    
    log "DEBUG" "Executing command: $cmd"
    
    # Execute command and capture output
    local output
    if output=$("$@" 2>&1); then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "DEBUG" "Command completed successfully in ${duration}s"
        if [[ -n "$output" ]]; then
            while IFS= read -r line; do
                [[ -n "$line" ]] && log "DEBUG" "Output: $line"
            done <<< "$output"
        fi
        return 0
    else
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        local exit_code=$?
        log "ERROR" "Command failed after ${duration}s with exit code $exit_code: $cmd"
        if [[ -n "$output" ]]; then
            while IFS= read -r line; do
                [[ -n "$line" ]] && log "ERROR" "Error output: $line"
            done <<< "$output"
        fi
        return $exit_code
    fi
}

# Log network operations
log_network_op() {
    local operation="$1"
    local resource="$2"
    local details="$3"
    log "INFO" "Network $operation: $resource $details"
}

# Log VPC lifecycle events
log_vpc_event() {
    local event="$1"
    local vpc_name="$2"
    local details="$3"
    log "INFO" "VPC $event: $vpc_name $details"
}

# Log firewall events
log_firewall_event() {
    local event="$1"
    local rule="$2"
    local target="$3"
    log "INFO" "Firewall $event: $rule -> $target"
}

# Function to view logs
show_logs() {
    local lines="${1:-50}"
    if [[ -f "$LOG_FILE" ]]; then
        echo "=== Last $lines lines of VPCCTL log ==="
        tail -n "$lines" "$LOG_FILE"
    else
        echo "Log file not found: $LOG_FILE"
    fi
}

# Function to clear logs
clear_logs() {
    if [[ -f "$LOG_FILE" ]]; then
        echo "" > "$LOG_FILE"
        log "INFO" "Logs cleared by user request"
    fi
}

# Function to set log level
set_log_level() {
    local level="$1"
    case "$level" in
        DEBUG|INFO|WARN|ERROR)
            LOG_LEVEL="$level"
            log "INFO" "Log level set to: $LOG_LEVEL"
            ;;
        *)
            error "Invalid log level: $level. Use DEBUG, INFO, WARN, or ERROR."
            return 1
            ;;
    esac
}
# ==================== END ENHANCED LOGGING SYSTEM ====================

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Initialize directories
init_dirs() {
    mkdir -p "$VPC_DIR"
    touch "$LOG_FILE"
    if [[ ! -f "$FIREWALL_RULES" ]]; then
        echo '{}' > "$FIREWALL_RULES"
    fi
}

# Validation functions
validate_cidr() {
    local cidr=$1
    if ! echo "$cidr" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$'; then
        error "Invalid CIDR format: $cidr"
        return 1
    fi
    return 0
}

# Simple IP calculation
get_gateway_ip() {
    local subnet_cidr=$1
    echo "$subnet_cidr" | sed 's|0/24$|1/24|'
}

get_host_ip() {
    local subnet_cidr=$1
    local host_num=$2
    echo "$subnet_cidr" | sed "s|0/24$|${host_num}/24|"
}

# Get host's internet interface
get_internet_interface() {
    ip route show default 2>/dev/null | awk '/default/ {print $5}' | head -1
}

# Enable IP forwarding and fix iptables
enable_networking() {
    # Enable IP forwarding
    if [[ "$(cat /proc/sys/net/ipv4/ip_forward)" != "1" ]]; then
        echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward >/dev/null
        info "IP forwarding enabled"
    fi
    
    # Fix iptables FORWARD rules for our bridges
    local bridges=$(ip link show type bridge | grep -o 'br-[^:]*' | head -1)
    for bridge in $bridges; do
        # Remove existing rules for this bridge
        sudo iptables -L FORWARD --line-numbers -n 2>/dev/null | grep "$bridge" | awk '{print $1}' | tac | while read line; do
            sudo iptables -D FORWARD $line 2>/dev/null || true
        done
        
        # Add allow rules for bridge traffic
        sudo iptables -I FORWARD 1 -i "$bridge" -o "$bridge" -j ACCEPT 2>/dev/null || true
        sudo iptables -I FORWARD 1 -i "$bridge" -j ACCEPT 2>/dev/null || true
        sudo iptables -I FORWARD 1 -o "$bridge" -j ACCEPT 2>/dev/null || true
    done
    
    # Set FORWARD policy to ACCEPT if it's DROP
    local forward_policy=$(sudo iptables -L FORWARD -n 2>/dev/null | grep 'Chain FORWARD' | awk '{print $4}' | tr -d ')' | head -1)
    if [[ "$forward_policy" == "DROP" ]]; then
        sudo iptables -P FORWARD ACCEPT
        info "FORWARD policy set to ACCEPT"
    fi
}

# Configure NAT for public subnets
configure_nat() {
    local vpc_name=$1
    local subnet_name=$2
    local cidr_block=$3
    local internet_interface=$4
    
    if [[ -z "$internet_interface" ]]; then
        internet_interface=$(get_internet_interface)
        if [[ -z "$internet_interface" ]]; then
            warn "No internet interface found. NAT will not work without internet connectivity."
            return 1
        fi
    fi
    
    info "Configuring NAT for subnet $subnet_name using interface $internet_interface"
    
    # Enable masquerading for public subnets
    sudo iptables -t nat -C POSTROUTING -s "$cidr_block" -o "$internet_interface" -j MASQUERADE 2>/dev/null ||
    sudo iptables -t nat -A POSTROUTING -s "$cidr_block" -o "$internet_interface" -j MASQUERADE
    
    # Allow forwarding from this subnet to internet
    sudo iptables -I FORWARD 1 -s "$cidr_block" -o "$internet_interface" -j ACCEPT 2>/dev/null || true
    sudo iptables -I FORWARD 1 -i "$internet_interface" -d "$cidr_block" -j ACCEPT 2>/dev/null || true
    
    success "NAT configured for $subnet_name ($cidr_block) -> $internet_interface"
}

# Block private subnets from internet
block_private_internet() {
    local cidr_block=$1
    local internet_interface=$2
    
    if [[ -z "$internet_interface" ]]; then
        internet_interface=$(get_internet_interface)
        if [[ -z "$internet_interface" ]]; then
            return 1
        fi
    fi
    
    # Block private subnets from reaching internet
    sudo iptables -C FORWARD -s "$cidr_block" -o "$internet_interface" -j DROP 2>/dev/null ||
    sudo iptables -I FORWARD 1 -s "$cidr_block" -o "$internet_interface" -j DROP
    
    info "Internet access blocked for private subnet $cidr_block"
}

# VPC Isolation Function - NEW ADDITION
strengthen_vpc_isolation() {
    local vpc_name=$1
    local bridge_name="br-${vpc_name}"
    
    info "Strengthening VPC isolation for $vpc_name"
    
    # Block traffic from this VPC to other VPC bridges
    local other_bridges=$(ip link show type bridge 2>/dev/null | grep -o 'br-[^:]*' | grep -v "$bridge_name")
    
    for other_bridge in $other_bridges; do
        if [[ "$other_bridge" != "$bridge_name" ]]; then
            # Block traffic between different VPC bridges
            sudo iptables -C FORWARD -i "$bridge_name" -o "$other_bridge" -j DROP 2>/dev/null ||
            sudo iptables -I FORWARD 1 -i "$bridge_name" -o "$other_bridge" -j DROP
            
            sudo iptables -C FORWARD -i "$other_bridge" -o "$bridge_name" -j DROP 2>/dev/null ||
            sudo iptables -I FORWARD 1 -i "$other_bridge" -o "$bridge_name" -j DROP
            
            debug "Blocked traffic between $bridge_name and $other_bridge"
        fi
    done
}

# Remove VPC isolation rules when VPC is deleted
remove_vpc_isolation() {
    local vpc_name=$1
    local bridge_name="br-${vpc_name}"
    
    info "Removing VPC isolation rules for $vpc_name"
    
    # Remove all iptables rules related to this bridge
    sudo iptables -L FORWARD --line-numbers -n 2>/dev/null | grep "$bridge_name" | awk '{print $1}' | tac | while read line; do
        sudo iptables -D FORWARD $line 2>/dev/null || true
    done
}

# Firewall/Security Groups functions
apply_firewall_rules() {
    local subnet_ns=$1
    local subnet_cidr=$2
    
    info "Applying firewall rules for $subnet_ns ($subnet_cidr)"
    
    # Check if firewall rules exist for this subnet
    local subnet_clean=$(echo "$subnet_cidr" | sed 's|/.*||')
    local rules=$(jq -r ".\"$subnet_clean\" // empty" "$FIREWALL_RULES" 2>/dev/null || echo "")
    
    if [[ -z "$rules" ]]; then
        debug "No firewall rules defined for $subnet_cidr"
        return 0
    fi
    
    # Clear existing rules in the namespace
    ip netns exec "$subnet_ns" iptables -F
    ip netns exec "$subnet_ns" iptables -X
    ip netns exec "$subnet_ns" iptables -Z
    
    # Set default policies
    ip netns exec "$subnet_ns" iptables -P INPUT DROP
    ip netns exec "$subnet_ns" iptables -P FORWARD DROP
    ip netns exec "$subnet_ns" iptables -P OUTPUT ACCEPT
    
    # Allow established connections
    ip netns exec "$subnet_ns" iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    ip netns exec "$subnet_ns" iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
    
    # Allow loopback
    ip netns exec "$subnet_ns" iptables -A INPUT -i lo -j ACCEPT
    
    # Parse and apply ingress rules
    local ingress_rules=$(echo "$rules" | jq -r '.ingress[]? | @base64' 2>/dev/null)
    if [[ -n "$ingress_rules" ]]; then
        while IFS= read -r rule; do
            if [[ -n "$rule" ]]; then
                local decoded_rule=$(echo "$rule" | base64 --decode)
                local port=$(echo "$decoded_rule" | jq -r '.port')
                local protocol=$(echo "$decoded_rule" | jq -r '.protocol')
                local action=$(echo "$decoded_rule" | jq -r '.action')
                
                if [[ "$action" == "allow" ]]; then
                    ip netns exec "$subnet_ns" iptables -A INPUT -p "$protocol" --dport "$port" -j ACCEPT
                    debug "ALLOW $protocol port $port -> $subnet_ns"
                elif [[ "$action" == "deny" ]]; then
                    ip netns exec "$subnet_ns" iptables -A INPUT -p "$protocol" --dport "$port" -j DROP
                    debug "DENY $protocol port $port -> $subnet_ns"
                fi
            fi
        done <<< "$ingress_rules"
    fi
    
    # Allow ICMP (ping) by default
    ip netns exec "$subnet_ns" iptables -A INPUT -p icmp -j ACCEPT
    
    success "Firewall rules applied to $subnet_ns"
}

add_firewall_rule() {
    local subnet_cidr=$1
    local port=$2
    local protocol=$3
    local action=$4
    
    info "Adding firewall rule: $action $protocol port $port for $subnet_cidr"
    
    # Validate inputs
    if [[ -z "$subnet_cidr" || -z "$port" || -z "$protocol" || -z "$action" ]]; then
        error "Missing required parameters: subnet_cidr, port, protocol, action"
        return 1
    fi
    
    if [[ "$action" != "allow" && "$action" != "deny" ]]; then
        error "Action must be 'allow' or 'deny'"
        return 1
    fi
    
    if [[ "$protocol" != "tcp" && "$protocol" != "udp" && "$protocol" != "icmp" ]]; then
        error "Protocol must be 'tcp', 'udp', or 'icmp'"
        return 1
    fi
    
    # Create rule entry
    local rule_entry="{\"port\": $port, \"protocol\": \"$protocol\", \"action\": \"$action\"}"
    local subnet_clean=$(echo "$subnet_cidr" | sed 's|/.*||')
    
    # Update JSON file
    if [[ ! -f "$FIREWALL_RULES" ]]; then
        echo '{}' > "$FIREWALL_RULES"
    fi
    
    # Use jq to update the rules
    local current_rules=$(cat "$FIREWALL_RULES")
    local updated_rules=$(echo "$current_rules" | jq --arg subnet "$subnet_clean" --argjson rule "$rule_entry" '
        if .[$subnet] then 
            .[$subnet].ingress += [$rule] 
        else 
            .[$subnet] = {"ingress": [$rule]} 
        end' 2>/dev/null)
    
    if [[ $? -eq 0 ]]; then
        echo "$updated_rules" > "$FIREWALL_RULES"
        success "Firewall rule added successfully"
        
        # Apply rules to existing namespaces
        apply_firewall_to_existing_namespaces "$subnet_clean"
    else
        error "Failed to update firewall rules. Is jq installed?"
        return 1
    fi
}

apply_firewall_to_existing_namespaces() {
    local subnet_ip=$1
    
    # Find all namespaces and apply rules if they match the subnet
    for ns in $(ip netns list | awk '{print $1}'); do
        if [[ "$ns" == subnet-* ]]; then
            # Get the veth interface in the namespace
            local veth_ns=$(ip netns exec "$ns" ip link show type veth 2>/dev/null | head -1 | awk -F: '{print $2}' | xargs)
            if [[ -n "$veth_ns" ]]; then
                local ns_ip=$(ip netns exec "$ns" ip addr show dev "$veth_ns" 2>/dev/null | grep 'inet ' | awk '{print $2}')
                local ns_ip_clean=$(echo "$ns_ip" | sed 's|/.*||')
                
                if [[ "$ns_ip_clean" == "$subnet_ip" ]]; then
                    apply_firewall_rules "$ns" "$ns_ip"
                fi
            fi
        fi
    done
}

list_firewall_rules() {
    info "Firewall Rules:"
    if [[ ! -f "$FIREWALL_RULES" ]] || [[ $(jq length "$FIREWALL_RULES") -eq 0 ]]; then
        echo "  No firewall rules defined"
        return 0
    fi
    
    jq -r 'to_entries[] | "  Subnet: \(.key)\n" + (.value.ingress // [] | map("    \(.action) \(.protocol) port \(.port)") | join("\n"))' "$FIREWALL_RULES" 2>/dev/null
}

clear_firewall_rules() {
    local subnet_cidr=$1
    
    if [[ -n "$subnet_cidr" ]]; then
        local subnet_clean=$(echo "$subnet_cidr" | sed 's|/.*||')
        local current_rules=$(cat "$FIREWALL_RULES")
        local updated_rules=$(echo "$current_rules" | jq "del(.[\"$subnet_clean\"])")
        echo "$updated_rules" > "$FIREWALL_RULES"
        info "Cleared firewall rules for $subnet_cidr"
    else
        echo '{}' > "$FIREWALL_RULES"
        info "Cleared all firewall rules"
    fi
}

# VPC Management
create_vpc() {
    local vpc_name=$1
    local cidr_block=$2
    validate_cidr "$cidr_block" || return 1
    info "Creating VPC: $vpc_name with CIDR: $cidr_block"
    
    # Enable networking first
    enable_networking
    
    # Create a bridge in the main namespace
    local bridge_name="br-${vpc_name}"
    if ! ip link show "$bridge_name" >/dev/null 2>&1; then
        ip link add "$bridge_name" type bridge
        ip link set "$bridge_name" up
        success "Created bridge: $bridge_name"
    fi
    
    echo "$cidr_block" > "$VPC_DIR/vpc-${vpc_name}.conf"
    
    # Strengthen VPC isolation - NEW ADDITION
    strengthen_vpc_isolation "$vpc_name"
    
    success "VPC $vpc_name created successfully"
}

create_subnet() {
    local vpc_name=$1
    local subnet_name=$2
    local subnet_type=$3
    local cidr_block=$4
    local internet_interface=$5
    validate_cidr "$cidr_block" || return 1
    
    info "Creating subnet: $subnet_name in VPC: $vpc_name (Type: $subnet_type, CIDR: $cidr_block)"
    
    local bridge_name="br-${vpc_name}"
    local subnet_ns="subnet-${vpc_name}-${subnet_name}"
    
    # Create namespace
    if ip netns list | grep -q "$subnet_ns"; then
        ip netns del "$subnet_ns"
    fi
    ip netns add "$subnet_ns"
    success "Created namespace: $subnet_ns"
    
    # Create SHORT veth pair names (under 15 chars)
    local veth_host="v-${vpc_name:0:2}-${subnet_name:0:2}-h"
    local veth_ns="v-${vpc_name:0:2}-${subnet_name:0:2}-n"
    
    # Remove existing veth pair if it exists
    if ip link show "$veth_host" >/dev/null 2>&1; then
        ip link del "$veth_host" 2>/dev/null || true
    fi
    
    # Create new veth pair
    ip link add "$veth_host" type veth peer name "$veth_ns"
    ip link set "$veth_ns" netns "$subnet_ns"
    success "Created veth pair: $veth_host <-> $veth_ns"
    
    # Connect host end to bridge
    ip link set "$veth_host" master "$bridge_name"
    ip link set "$veth_host" up
    
    # Configure namespace side
    ip netns exec "$subnet_ns" ip link set lo up
    ip netns exec "$subnet_ns" ip link set "$veth_ns" up
    
    # Calculate IPs
    local gateway_ip=$(get_gateway_ip "$cidr_block")
    local subnet_ip=$(get_host_ip "$cidr_block" "10")
    local gateway_ip_raw="${gateway_ip%/*}"
    
    # Remove any existing IP from bridge for this subnet
    ip addr del "$gateway_ip" dev "$bridge_name" 2>/dev/null || true
    
    # Assign gateway IP to bridge with correct netmask
    ip addr add "$gateway_ip" dev "$bridge_name"
    
    # Assign IP to namespace side
    ip netns exec "$subnet_ns" ip addr add "$subnet_ip" dev "$veth_ns"
    
    # Set up route in namespace
    ip netns exec "$subnet_ns" ip route add default via "$gateway_ip_raw" dev "$veth_ns"
    
    # Configure NAT based on subnet type
    if [[ "$subnet_type" == "public" ]]; then
        configure_nat "$vpc_name" "$subnet_name" "$cidr_block" "$internet_interface"
    elif [[ "$subnet_type" == "private" ]]; then
        block_private_internet "$cidr_block" "$internet_interface"
    fi
    
    # Apply firewall rules to the new subnet
    apply_firewall_rules "$subnet_ns" "$cidr_block"
    
    # Store configuration
    cat > "$VPC_DIR/subnet-${vpc_name}-${subnet_name}.conf" << EOC
SUBNET_NAME=$subnet_name
SUBNET_TYPE=$subnet_type
CIDR_BLOCK=$cidr_block
GATEWAY_IP=$gateway_ip
NAMESPACE=$subnet_ns
VETH_NS=$veth_ns
EOC
    
    success "Subnet $subnet_name created successfully"
}

delete_subnet() {
    local vpc_name=$1
    local subnet_name=$2
    local subnet_ns="subnet-${vpc_name}-${subnet_name}"
    local veth_host="v-${vpc_name:0:2}-${subnet_name:0:2}-h"
    
    if ip netns list | grep -q "$subnet_ns"; then
        ip netns del "$subnet_ns"
        info "Deleted subnet namespace: $subnet_ns"
    fi
    
    if ip link show "$veth_host" >/dev/null 2>&1; then
        ip link del "$veth_host"
        info "Deleted veth interface: $veth_host"
    fi
    
    rm -f "$VPC_DIR/subnet-${vpc_name}-${subnet_name}.conf"
    info "Subnet $subnet_name deleted from VPC $vpc_name"
}

delete_vpc() {
    local vpc_name=$1
    info "Deleting VPC: $vpc_name"
    local bridge_name="br-${vpc_name}"
    
    # Remove VPC isolation rules - NEW ADDITION
    remove_vpc_isolation "$vpc_name"
    
    # Delete all subnets first
    for subnet_conf in "$VPC_DIR"/subnet-"${vpc_name}"-*.conf; do
        if [[ -f "$subnet_conf" ]]; then
            local subnet_name=$(basename "$subnet_conf" .conf | sed 's/subnet-'"${vpc_name}"'-//')
            delete_subnet "$vpc_name" "$subnet_name"
        fi
    done
    
    if ip link show "$bridge_name" >/dev/null 2>&1; then
        ip link del "$bridge_name"
        info "Deleted bridge: $bridge_name"
    fi
    
    rm -f "$VPC_DIR/vpc-${vpc_name}.conf"
    success "VPC $vpc_name deleted successfully"
}

deploy_workload() {
    local vpc_name=$1
    local subnet_name=$2
    local workload_name=$3
    local workload_ip=$4
    local subnet_ns="subnet-${vpc_name}-${subnet_name}"
    
    if ! ip netns list | grep -q "$subnet_ns"; then
        error "Subnet $subnet_name not found in VPC $vpc_name"
        return 1
    fi
    
    local subnet_conf="$VPC_DIR/subnet-${vpc_name}-${subnet_name}.conf"
    if [[ ! -f "$subnet_conf" ]]; then
        error "Subnet configuration not found for $subnet_name"
        return 1
    fi
    source "$subnet_conf"
    
    info "Deploying workload $workload_name in subnet $subnet_name (IP: $workload_ip)"
    
    # Add the workload IP to the existing interface
    ip netns exec "$subnet_ns" ip addr add "$workload_ip/24" dev "$VETH_NS"
    
    # Start web server
    ip netns exec "$subnet_ns" bash -c "
        cd /tmp
        echo '<html><body><h1>Workload: $workload_name</h1><p>VPC: $vpc_name</p><p>Subnet: $subnet_name</p><p>IP: $workload_ip</p><p>Time: $(date)</p></body></html>' > index-$workload_name.html
        nohup python3 -m http.server 80 --bind $workload_ip > /tmp/webserver-$workload_name.log 2>&1 &
        echo \$! > /tmp/webserver-$workload_name.pid
        sleep 1
    "
    
    sleep 2
    success "Workload $workload_name deployed and serving on $workload_ip:80"
}

test_connectivity() {
    local source_ns=$1
    local target_ip=$2
    local port=${3:-80}
    
    info "Testing connectivity from $source_ns to $target_ip:$port"
    
    # Ensure networking is enabled
    enable_networking
    
    if [[ "$port" == "icmp" ]]; then
        if ip netns exec "$source_ns" ping -c 2 -W 1 "$target_ip" >/dev/null 2>&1; then
            echo "SUCCESS: Can reach $target_ip from $source_ns (ICMP)"
            return 0
        else
            echo "FAILED: Cannot reach $target_ip from $source_ns (ICMP)"
            return 1
        fi
    else
        if ip netns exec "$source_ns" timeout 2 bash -c "echo > /dev/tcp/$target_ip/$port" 2>/dev/null; then
            echo "SUCCESS: Can reach $target_ip:$port from $source_ns"
            return 0
        else
            echo "FAILED: Cannot reach $target_ip:$port from $source_ns"
            return 1
        fi
    fi
}

# Test internet access from a namespace
test_internet_access() {
    local namespace=$1
    info "Testing internet access from $namespace"
    
    if ip netns exec "$namespace" ping -c 2 -W 1 8.8.8.8 >/dev/null 2>&1; then
        echo "SUCCESS: $namespace has internet access"
        return 0
    else
        echo "FAILED: $namespace has NO internet access"
        return 1
    fi
}

list_vpcs() {
    info "Available VPCs:"
    for vpc_conf in "$VPC_DIR"/vpc-*.conf; do
        if [[ -f "$vpc_conf" ]]; then
            local vpc_name=$(basename "$vpc_conf" .conf | sed 's/vpc-//')
            local cidr=$(cat "$vpc_conf")
            echo "  VPC: $vpc_name, CIDR: $cidr"
            for subnet_conf in "$VPC_DIR"/subnet-"${vpc_name}"-*.conf; do
                if [[ -f "$subnet_conf" ]]; then
                    source "$subnet_conf"
                    echo "    Subnet: $SUBNET_NAME ($SUBNET_TYPE) - $CIDR_BLOCK"
                fi
            done
        fi
    done
}

cleanup_all() {
    info "Cleaning up all VPC resources..."
    for vpc_conf in "$VPC_DIR"/vpc-*.conf; do
        if [[ -f "$vpc_conf" ]]; then
            local vpc_name=$(basename "$vpc_conf" .conf | sed 's/vpc-//')
            delete_vpc "$vpc_name"
        fi
    done
    rm -rf "$VPC_DIR"
    success "All VPC resources cleaned up"
}

show_status() {
    echo "=== VPC Status ==="
    echo "Bridges:"
    ip link show type bridge 2>/dev/null || echo "  No bridges found"
    echo ""
    echo "Namespaces:"
    ip netns list || echo "  No namespaces found"
    echo ""
    echo "IP Forwarding: $(cat /proc/sys/net/ipv4/ip_forward)"
    echo ""
    echo "NAT Rules:"
    sudo iptables -t nat -L POSTROUTING -n 2>/dev/null | grep MASQUERADE || echo "  No NAT rules found"
    echo ""
    echo "VPC Isolation Rules:"
    sudo iptables -L FORWARD -n 2>/dev/null | grep DROP | grep -E 'br-[a-z]' || echo "  No VPC isolation rules found"
    echo ""
    list_firewall_rules
}

# VPC Peering functions
create_peering() {
    local vpc1_name=$1
    local vpc2_name=$2
    
    info "Creating VPC peering between $vpc1_name and $vpc2_name"
    
    # Check if VPCs exist
    if [[ ! -f "$VPC_DIR/vpc-${vpc1_name}.conf" ]]; then
        error "VPC $vpc1_name does not exist"
        return 1
    fi
    if [[ ! -f "$VPC_DIR/vpc-${vpc2_name}.conf" ]]; then
        error "VPC $vpc2_name does not exist"
        return 1
    fi
    
    # Check if peering already exists
    if [[ -f "$VPC_DIR/peering-${vpc1_name}-${vpc2_name}.conf" ]] || \
       [[ -f "$VPC_DIR/peering-${vpc2_name}-${vpc1_name}.conf" ]]; then
        error "Peering between $vpc1_name and $vpc2_name already exists"
        return 1
    fi
    
    local bridge1="br-${vpc1_name}"
    local bridge2="br-${vpc2_name}"
    
    # Create SHORT veth pair names (under 15 chars)
    local peer_veth1="p-${vpc1_name:0:3}-${vpc2_name:0:3}-1"
    local peer_veth2="p-${vpc1_name:0:3}-${vpc2_name:0:3}-2"
    
    # Remove existing veth pair if it exists
    if ip link show "$peer_veth1" >/dev/null 2>&1; then
        ip link del "$peer_veth1" 2>/dev/null || true
    fi
    
    # Create veth pair
    ip link add "$peer_veth1" type veth peer name "$peer_veth2"
    ip link set "$peer_veth1" up
    ip link set "$peer_veth2" up
    
    # Connect each end to respective bridges
    ip link set "$peer_veth1" master "$bridge1"
    ip link set "$peer_veth2" master "$bridge2"
    
    # Remove isolation rules between these two VPCs
    sudo iptables -D FORWARD -i "$bridge1" -o "$bridge2" -j DROP 2>/dev/null || true
    sudo iptables -D FORWARD -i "$bridge2" -o "$bridge1" -j DROP 2>/dev/null || true
    
    # Get VPC CIDRs
    local vpc1_cidr=$(cat "$VPC_DIR/vpc-${vpc1_name}.conf")
    local vpc2_cidr=$(cat "$VPC_DIR/vpc-${vpc2_name}.conf")
    
    # Store peering configuration
    cat > "$VPC_DIR/peering-${vpc1_name}-${vpc2_name}.conf" << EOC
VPC1=$vpc1_name
VPC2=$vpc2_name
VPC1_CIDR=$vpc1_cidr
VPC2_CIDR=$vpc2_cidr
PEER_VETH1=$peer_veth1
PEER_VETH2=$peer_veth2
CREATED_AT="$(date '+%Y-%m-%d %H:%M:%S')"
EOC
    
    success "VPC peering between $vpc1_name and $vpc2_name established successfully"
}

delete_peering() {
    local vpc1_name=$1
    local vpc2_name=$2
    
    local peer_conf="$VPC_DIR/peering-${vpc1_name}-${vpc2_name}.conf"
    if [[ ! -f "$peer_conf" ]]; then
        peer_conf="$VPC_DIR/peering-${vpc2_name}-${vpc1_name}.conf"
        if [[ ! -f "$peer_conf" ]]; then
            error "Peering between $vpc1_name and $vpc2_name does not exist"
            return 1
        fi
    fi
    
    source "$peer_conf"
    
    # Remove veth pair
    if ip link show "$PEER_VETH1" >/dev/null 2>&1; then
        ip link del "$PEER_VETH1"
    fi
    
    # Restore isolation rules between these VPCs
    local bridge1="br-${vpc1_name}"
    local bridge2="br-${vpc2_name}"
    sudo iptables -C FORWARD -i "$bridge1" -o "$bridge2" -j DROP 2>/dev/null ||
    sudo iptables -I FORWARD 1 -i "$bridge1" -o "$bridge2" -j DROP
    sudo iptables -C FORWARD -i "$bridge2" -o "$bridge1" -j DROP 2>/dev/null ||
    sudo iptables -I FORWARD 1 -i "$bridge2" -o "$bridge1" -j DROP
    
    rm -f "$peer_conf"
    info "VPC peering between $vpc1_name and $vpc2_name deleted"
}

list_peerings() {
    info "VPC Peerings:"
    for peer_conf in "$VPC_DIR"/peering-*.conf; do
        if [[ -f "$peer_conf" ]]; then
            source "$peer_conf"
            echo "  $VPC1 <-> $VPC2"
            echo "    VPC1 CIDR: $VPC1_CIDR"
            echo "    VPC2 CIDR: $VPC2_CIDR"
            echo "    Created: $CREATED_AT"
        fi
    done
    if [[ ! $(find "$VPC_DIR" -name "peering-*.conf" | head -1) ]]; then
        echo "  No VPC peerings found"
    fi
}

main() {
    init_dirs
    case $1 in
        create-vpc)
            create_vpc "$2" "$3"
            ;;
        delete-vpc)
            delete_vpc "$2"
            ;;
        create-subnet)
            if [[ -n "$6" ]]; then
                create_subnet "$2" "$3" "$4" "$5" "$6"
            else
                create_subnet "$2" "$3" "$4" "$5"
            fi
            ;;
        delete-subnet)
            delete_subnet "$2" "$3"
            ;;
        deploy-workload)
            deploy_workload "$2" "$3" "$4" "$5"
            ;;
        list)
            list_vpcs
            ;;
        test-connectivity)
            test_connectivity "$2" "$3" "$4"
            ;;
        test-internet)
            test_internet_access "$2"
            ;;
        cleanup-all)
            cleanup_all
            ;;
        enable-networking)
            enable_networking
            ;;
        status)
            show_status
            ;;
        create-peering)
            create_peering "$2" "$3"
            ;;
        delete-peering)
            delete_peering "$2" "$3"
            ;;
        list-peerings)
            list_peerings
            ;;
        # Firewall commands
        add-firewall-rule)
            add_firewall_rule "$2" "$3" "$4" "$5"
            ;;
        list-firewall-rules)
            list_firewall_rules
            ;;
        clear-firewall-rules)
            clear_firewall_rules "$2"
            ;;
        apply-firewall)
            apply_firewall_to_existing_namespaces "$2"
            ;;
        # Log management commands
        show-logs)
            show_logs "$2"
            ;;
        clear-logs)
            clear_logs
            ;;
        set-log-level)
            set_log_level "$2"
            ;;
        log-status)
            echo "=== Log Status ==="
            echo "Log file: $LOG_FILE"
            echo "Log level: $LOG_LEVEL"
            echo "Log size: $(du -h "$LOG_FILE" 2>/dev/null | cut -f1 || echo "0")"
            echo "Backup count: $BACKUP_COUNT"
            echo "Max log size: $((MAX_LOG_SIZE / 1024 / 1024))MB"
            ;;
        *)
            cat << EOU
Usage: $0 <command> [arguments]

VPC Management Commands:
  create-vpc <name> <cidr>                    Create a new VPC
  delete-vpc <name>                           Delete a VPC
  create-subnet <vpc> <name> <type> <cidr> [interface]  Create subnet (public/private)
  delete-subnet <vpc> <name>                  Delete a subnet
  deploy-workload <vpc> <subnet> <name> <ip>  Deploy test workload
  list                                        List all VPCs and subnets

Testing Commands:
  test-connectivity <namespace> <ip> [port]   Test connectivity between namespaces
  test-internet <namespace>                   Test internet access from namespace

VPC Peering Commands:
  create-peering <vpc1> <vpc2>                Create VPC peering connection
  delete-peering <vpc1> <vpc2>                Delete VPC peering connection
  list-peerings                               List all VPC peerings

Firewall/Security Group Commands:
  add-firewall-rule <subnet_cidr> <port> <protocol> <action>  Add firewall rule
  list-firewall-rules                         List all firewall rules
  clear-firewall-rules [subnet_cidr]          Clear firewall rules (all or specific subnet)
  apply-firewall [subnet_ip]                  Apply firewall rules to existing namespaces

Log Management Commands:
  show-logs [lines]                    Show last N lines of log (default: 50)
  clear-logs                           Clear all log files
  set-log-level <level>                Set log level (DEBUG, INFO, WARN, ERROR)
  log-status                           Show logging configuration status

Utility Commands:
  enable-networking                           Enable IP forwarding and fix iptables
  status                                      Show current VPC status
  cleanup-all                                 Clean up all VPC resources

Examples:
  # Create VPC and subnets
  $0 create-vpc myvpc 10.0.0.0/16
  $0 create-subnet myvpc public public 10.0.1.0/24 eth0
  $0 create-subnet myvpc private private 10.0.2.0/24

  # Deploy workloads
  $0 deploy-workload myvpc public web1 10.0.1.10
  $0 deploy-workload myvpc private app1 10.0.2.10

  # Firewall rules
  $0 add-firewall-rule 10.0.1.0/24 80 tcp allow
  $0 add-firewall-rule 10.0.1.0/24 22 tcp deny
  $0 list-firewall-rules

  # Test connectivity
  $0 test-internet subnet-myvpc-public
  $0 test-connectivity subnet-myvpc-public 10.0.2.10

  # VPC Peering
  $0 create-vpc vpc1 10.1.0.0/16
  $0 create-vpc vpc2 10.2.0.0/16
  $0 create-peering vpc1 vpc2
  $0 list-peerings

  # Log management
  $0 show-logs 20
  $0 set-log-level DEBUG
  $0 log-status

  # Cleanup
  $0 cleanup-all
EOU
            exit 1
            ;;
    esac
}

main "$@"